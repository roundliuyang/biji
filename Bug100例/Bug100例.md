## 1、Spring Bean 空指针异常

在项目启动过程中，有众多阶段。

![1636100525274](Bug100例.assets/1636100525274.png)



例如：

如果WebApplicationContext: initialization completed  没有完成，此时接口访问会响应：Error: connect ECONNREFUSED 127.0.0.1:18091



如果WebApplicationContext: initialization completed  ，但spring bean  还未初始化成功，此时接口访问有可能报 注入的Bean 空指针异常

例如：在Filter中，注入spring bean （如在filter中注入RedisTemplate Bean）,在spring bean 未初始化成功之前访问接口，报如下错误。

![1636101632811](Bug100例.assets/1636101632811.png)



如果项目成功启动则可以正常访问。



## 2、空指针异常

例如：

```java
	public void test(){
		String[] s=null;
		ArrayList<String> list = new ArrayList<>();
		Collections.addAll(list, s);
	}
```

报空指针异常：

```java
java.lang.NullPointerException
	at java.util.Collections.addAll(Collections.java:5400)
	at com.yly.java.stream.TestStreamAPI1.test23(TestStreamAPI1.java:107)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	......
    ......
```



### 什么是空指针异常?

空指针异常指的是当前的对象指向了一段`null`的内存区域，而开发者用`null`进行了其他操作，引发的JVM堆栈异常。
 编译时程序无法推断出这个对象是否会为`null`，而在程序运行的时候，它执行了`null`所不具备的能力，这个时候JVM会向你抛出`NullPointException`,告诉你，这个地方的引用是空的，无法继续往下执行了。

### 经典案例

User

```java
package exception;

import lombok.Data;

import java.util.Collections;
import java.util.List;

@Data
public class User {
    private String userName;
    private String password;
    private Integer age;

    /**
     * 返回空集合，用于演示NPE
     * @return
     */
    public static List<User> getNullInstances(){
        return null;
    }
}

```

- **业务对象为空，导致程序报NPE**

```java
User user = getDataById(100);
// 如果根据id:100无法查询到具体的User实例，那么此时的user就是null,那么null.getxxx()就会触发NPE了
String userName = user.getUserName();
```

- **集合操作时没有进行判空，导致程序报NPE**

```java
        List<User> userList = User.getNullInstances();
        System.out.println(userList.size());
```

- **回收资源的时候，没有进行判空处理**

  ```java
          BufferedReader bufferedReader = null;
          try {
              File file = new File("C:\\Users\\95152\\Desktop\\sql.txt");
              FileReader fileReader = new FileReader(file);
              bufferedReader = new BufferedReader(fileReader);
              String readLine = bufferedReader.readLine();
              System.out.println(readLine);
          } catch (IOException e) {
              e.printStackTrace();
          } finally {
              try {
                  // 这里的bufferedReader可能为空，直接调用close可能会报错
                  bufferedReader.close();
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
  ```



### 高发区域

- 进行数据库查询操作时，未进行判空就直接使用，容易引发NPE
- 远程调用或者Http调用第三方接口时，未进行判空就进行了下一步处理，容易引发NPE
- 从中间件获取数据时，未进行判空就直接处理，容易引发NPE
- 集合操作时，使用了null作为了操作目标，容易引发NPE
- toString()

### 如何保持代码的鲁棒性，避免NPE?

- 对对象或者集合进行操作时，需要检验是否会出现空的情况,对对象或者集合判空校验。
- 如果编写了工具类有定义返回的结果集，那么不要直接返回`null`，抛出异常或者返回空对象或许更加好
- 使用Optional
- 使用断言
- String可以使用StringUtils.isBlank()进行判空，集合可以使用CollectionUtils.isEmpty()进行判空
- JDK7提供了一个Objects类，使用Objects.isNull()可以帮助你写出可读性更友好的代码

## 3、日期与时间异常

接口传输时间时，尽量不要用字符串表示，否侧可能出现时区错误。如，传08:00给欧洲，他用他们的服务器（即它们的时区）转换成时间戳并传输给我们，哪个时间戳用我们的时区转换得到错误的结果。例如他们是gmt+0时区，需要他们把时间从08:00转换成00:00,然后再转换成时间戳，或者我们用gmt+0的时区转换时间戳为日期。



## 4、util.date转TimeStamp问题

**问：**从页面接收的日期 先转为java.util.date 后 在转为TimeStamp类型插入数据库
现在的问题是 转为java.util.date 后，数据为Tue Jan 01 08:00:00 CST 2013
用

```
// 获取当前时间:
Date date = new Date();
Timestamp startTime = new Timestamp(date.getTime());
System.out.println(startTime);
```

转后得到的数据为

```
2022-01-05 12:28:22.309
```

后面多了一个.309

但是查询MySQL数据库里面 数据却为2022-01-05 12:28:22 ?

**答：**在jdk的帮助文档中写了关于这个。 一个与 java.util.Date 类有关的瘦包装器 (thin wrapper)，它允许 JDBC API 将该类标识为 SQL TIMESTAMP 值。它通过允许小数秒到纳秒级精度的规范来添加保存 SQL TIMESTAMP 小数秒值的能力。Timestamp 也提供支持时间戳值的 JDBC 转义语法的格式化和解析操作的能力。 计算 Timestamp 对象的精度为二者之一： 19 ，其为 yyyy-mm-dd hh:mm:ss 格式下的字符数 20 + s ，其为 yyyy-mm-dd hh:mm:ss.[fff...] 格式下的字符数，s 表示给定 Timestamp 的标度（其小数秒精度）。 注：此类型由 java.util.Date 和单独的毫微秒值组成。只有整数秒才会存储在 java.util.Date 组件中。小数秒（毫微秒）是独立存在的。传递不是 java.sql.Timestamp 实例的对象时，Timestamp.equals(Object) 方法永远不会返回 true，因为日期的毫微秒组件是未知的。因此，相对于 java.util.Date.equals(Object) 方法而言，Timestamp.equals(Object) 方法是不对称的。此外，hashcode 方法使用底层 java.util.Date 实现并因此在其计算中不包括毫微秒 你查数据的时候，应该是用MySQL的方法规范了它的输出格式。

一般情况下，日期时间类型的字段，resultMap 和 参数中不显示的指定时，mybatis会自动做类型映射成DATETIME（yyyy/MM/dd HH:MM:SS）；如果指定jdbcType="DATE"，则存入数据库和取出的时间格式yyyy/MM/dd 

## 5、时区差8小时问题解决

时区差八小时这个问题在程序员身上很普通

普及:

```
 注:采用+8:00格式,没有指定MySQL驱动版本的情况下它自动依赖的驱动高版本的mysql，这是由于数据库和系统时区差异所造成的，mysql默认的是美国的时区，而我们中国大陆要比他们迟8小时,在jdbc连接的url后面加上serverTimezone=GMT即可解决问题，如果需要使用gmt+8时区，需要写成GMT%2B8，否则会被解析为空。再一个解决办法就是使用低版本的MySQL jdbc驱动不会存在时区的问题。
这个时区要设置好，不然会出现时差， 
如果你设置serverTimezone=UTC，连接不报错， 
但是我们在用java代码插入到数据库时间的时候却出现了问题。 
比如在java代码里面插入的时间为：2018-06-24 17:29:56 
但是在数据库里面显示的时间却为：2018-06-24 09:29:56 
有了8个小时的时差 
UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。
```

解决方式如下

方式一:

当用new date()或者TimeZone时有8小时的时差问题：   

保证服务器时区为东八区时间即北京时间 服务启动的时候，将当前时区设置为GMT+8，代码如下：

```
	@SpringBootApplication
	public class Application {
	  @PostConstruct
	  void started() {
	  TimeZone.setDefault(TimeZone.getTimeZone("GMT+8"));
	//TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
	//TimeZone.setDefault(TimeZone.getTimeZone("Asia/Shanghai"));
	}

public static void main(String[] args) { SpringApplication.run(Application.class, args); } }
```

这样就保证了Java程序的时区为北京东八区时间。

方式二 : 在application.yml中配置

```
spring:
   #解决前端取回日期少8个小时问题
    jackson:
	date-format: yyyy/MM/dd HH:mm:ss
	time-zone: GMT+8
    datasource:
      #基本属性
	url: jdbc:mysql://localhost:3306/gwork?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false&serverTimezone=GMT%2b8
```

方式三 : 数据库驱动连接上配置

```
 url: jdbc:mysql://localhost:3306/gwork?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false&serverTimezone=GMT%2b8
```

