## 单例

## 工厂

### 抽象工厂



### 工厂方法

**模式定义**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类。

![](https://p0.meituan.net/travelcube/653ab8f2224eaf4c392b59cae96c30d440308.png)

我们通过一段较为通用的代码来解释如何使用工厂模式：

```java
//抽象的产品
public abstract class Product {
    public abstract void method();
}
//定义一个具体的产品 (可以定义多个具体的产品)
class ProductA extends Product {
    @Override
    public void method() {}  //具体的执行逻辑
}
//抽象的工厂
abstract class Factory<T> {
    abstract Product createProduct(Class<T> c);
}
//具体的工厂可以生产出相应的产品
class FactoryA extends Factory{
    @Override
    Product createProduct(Class c) {
        Product product = (Product) Class.forName(c.getName()).newInstance();
        return product;
    }
}
```



## 策略

### 案例一

策略设计模式是行为设计模式的一种。当我们针对特定任务有多种算法并且客户端决定在运行时使用的实际实现时，将使用策略模式。

策略模式也称为策略模式。我们定义了多个算法，并让客户端应用程序传递要用作参数的算法。

策略模式的最佳示例之一是采用 Comparator 参数的 Collections.sort() 方法。基于 Comparator 接口的不同实现，对象以不同的方式进行排序。

对于我们的示例，我们将尝试实现一个简单的购物车，其中有两种付款策略——使用信用卡或使用 PayPal。



**首先，我们将为我们的策略模式示例创建接口，在我们的例子中支付作为参数传递的金额。**

```java
//支付策略接口
public interface PaymentStrategy {

	public void pay(int amount);
}

```

**现在，我们将不得不创建具体的算法实现，以使用信用卡/借记卡或通过Paypal付款。**

```java
// 信用卡支付
public class CreditCardStrategy implements PaymentStrategy {

	private String name;
	private String cardNumber;
	private String cvv;
	private String dateOfExpiry;
	
	public CreditCardStrategy(String nm, String ccNum, String cvv, String expiryDate){
		this.name=nm;
		this.cardNumber=ccNum;
		this.cvv=cvv;
		this.dateOfExpiry=expiryDate;
	}
	@Override
	public void pay(int amount) {
		System.out.println(amount +" paid with credit/debit card");
	}

}
```

​	

```java
// Paypal 支付
public class PaypalStrategy implements PaymentStrategy {

	private String emailId;
	private String password;
	
	public PaypalStrategy(String email, String pwd){
		this.emailId=email;
		this.password=pwd;
	}
	
	@Override
	public void pay(int amount) {
		System.out.println(amount + " paid using Paypal.");
	}

}
```



**现在我们的策略模式实例算法已经准备好了。我们可以实现购物车，支付方式需要输入支付策略**

```java
// 商品类
public class Item {

	private String upcCode;
	private int price;
	
	public Item(String upc, int cost){
		this.upcCode=upc;
		this.price=cost;
	}

	public String getUpcCode() {
		return upcCode;
	}

	public int getPrice() {
		return price;
	}
	
}
```

```java
// 购物车
public class ShoppingCart {

	//List of items
	List<Item> items;
	
	public ShoppingCart(){
		this.items=new ArrayList<Item>();
	}
	
	public void addItem(Item item){
		this.items.add(item);
	}
	
	public void removeItem(Item item){
		this.items.remove(item);
	}
	
	public int calculateTotal(){
		int sum = 0;
		for(Item item : items){
			sum += item.getPrice();
		}
		return sum;
	}
	
	public void pay(PaymentStrategy paymentMethod){
		int amount = calculateTotal();
		paymentMethod.pay(amount);
	}
}
```

请注意，购物车的支付方式需要支付算法作为参数，并且不会将其作为实例变量存储在任何地方。

让我们用一个简单的程序测试我们的策略模式示例设置。

```java
// 测试类
public class ShoppingCartTest {

	public static void main(String[] args) {
		ShoppingCart cart = new ShoppingCart();
		
		Item item1 = new Item("1234",10);
		Item item2 = new Item("5678",40);
		
		cart.addItem(item1);
		cart.addItem(item2);
		
		//pay by paypal
		cart.pay(new PaypalStrategy("myemail@example.com", "mypwd"));
		
		//pay by credit card
		cart.pay(new CreditCardStrategy("Pankaj Kumar", "1234567890123456", "786", "12/15"));
	}
}
```

上述程序的输出是：

```java

50 paid using Paypal.
50 paid with credit/debit card
```

策略设计模式类图

![Strategy Pattern, Strategy Design pattern in java](设计模式.assets/Strategy-Pattern-450x261.png)

### 策略设计模式要点

我们本可以使用组合来为策略创建实例变量，但我们应该避免这样做，因为我们希望特定的策略能够应用于某个特定的任务。在Collections.sort()和Arrays.sort()方法中也是如此，它们以比较器作为参数。

策略模式与状态模式非常相似。其中一个区别是，Context包含作为实例变量的状态，并且可以有多个任务的实现依赖于状态，而在策略模式中，策略是作为参数传递给方法的，Context对象没有任何变量来存储它。

当我们有多种算法用于特定的任务，并且我们希望我们的应用程序能够灵活地在运行时为特定的任务选择任何一种算法时，策略模式就非常有用。

### 案例二

模式定义：定义一系列算法，将每个算法都封装起来，并且它们可以互换。策略模式是一种对象行为模式。

策略模式通用类图如下:

![](https://p0.meituan.net/travelcube/a2282c7a7cef61e35d29db6bd27c824034361.png)

我们通过一段比较通用的代码来解释怎么使用策略模式：

```java
//定义一个策略接口
public interface Strategy {
    void strategyImplementation();
}

//具体的策略实现(可以定义多个具体的策略实现)
public class StrategyA implements Strategy{
    @Override
    public void strategyImplementation() {
        System.out.println("正在执行策略A");
    }
}

//封装策略，屏蔽高层模块对策略、算法的直接访问，屏蔽可能存在的策略变化
public class Context {
    private Strategy strategy = null;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
  
    public void doStrategy() {
        strategy.strategyImplementation();
    }
}
```



## 状态模式

### 案例一

状态设计模式是行为设计模式的一种。当对象根据其内部状态改变其行为时，将使用状态设计模式

如果我们必须根据一个对象的状态来改变它的行为，我们可以在对象中设置一个状态变量。然后使用if-else条件块，根据状态执行不同的动作。状态设计模式被用来提供一种系统的、松散耦合的方式，通过Context和State的实现来实现这一目标。

状态模式的Context是拥有State引用的类，它是State的一个具体实现。Context将请求转发给state对象进行处理。让我们通过一个简单的例子来理解这一点。

假设我们想实现一个带有简单按钮的电视遥控器来执行动作。如果状态是ON，它将打开电视，如果状态是OFF，它将关闭电视。

我们可以使用下面的if-else条件来实现它。

```java
public class TVRemoteBasic {

	private String state="";
	
	public void setState(String state){
		this.state=state;
	}
	
	public void doAction(){
		if(state.equalsIgnoreCase("ON")){
			System.out.println("TV is turned ON");
		}else if(state.equalsIgnoreCase("OFF")){
			System.out.println("TV is turned OFF");
		}
	}

	public static void main(String args[]){
		TVRemoteBasic remote = new TVRemoteBasic();
		
		remote.setState("ON");
		remote.doAction();
		
		remote.setState("OFF");
		remote.doAction();
	}

}
```

请注意，客户端代码应该知道用于设置远程状态的具体数值。此外，如果状态的数量增加，那么实现和客户端代码之间的紧密耦合将很难维护和扩展。

##### 状态设计模式接口

首先，我们将创建State接口，它将定义不同的具体状态和上下文类应该实现的方法。

```java
// State接口
public interface State {
    
	public void doAction();
}
```

##### 状态设计模式具体状态实现

在我们的示例中，我们可以有两种状态——一种用于打开电视，另一种用于关闭电视。因此，我们将为这些行为创建两个具体的状态实现。

```java
public class TVStartState implements State {

	@Override
	public void doAction() {
		System.out.println("TV is turned ON");
	}

}
```

```java
public class TVStopState implements State {

	@Override
	public void doAction() {
		System.out.println("TV is turned OFF");
	}

}
```

现在我们准备实现我们的 Context 对象，它将根据其内部状态改变其行为。

##### 状态设计模式上下文实现

```java
public class TVContext implements State {

	private State tvState;

	public void setState(State state) {
		this.tvState=state;
	}

	public State getState() {
		return this.tvState;
	}

	@Override
	public void doAction() {
		this.tvState.doAction();
	}

}
```

请注意，Context也实现了State，并保持其当前状态的引用，并将请求转发给state的实现

##### 状态设计模式测试程序

现在让我们编写一个简单的程序来测试 TV Remote 的状态模式实现。

```java
public class TVRemote {

	public static void main(String[] args) {
		TVContext context = new TVContext();
		State tvStartState = new TVStartState();
		State tvStopState = new TVStopState();
		
		context.setState(tvStartState);
		context.doAction();
		
		
		context.setState(tvStopState);
		context.doAction();
		
	}

}
```

上述程序的输出与不使用状态模式的 TV Remote 的基本实现相同。

##### 状态设计模式的好处

使用状态模式实现多态行为的好处显而易见。出错的机会更少，而且很容易为额外的行为添加更多的状态。从而使我们的代码更加健壮、易于维护和灵活。在这种情况下，状态模式也有助于避免 if-else 或 switch-case 条件逻辑。

状态模式与策略模式非常相似，请查看 Java 中的策略模式。

### 案例二

**模式定义**：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。

状态模式的通用类图如下图所示：

![](https://p0.meituan.net/travelcube/75e091982ed46532e674419ddfffb4cb40964.png)

对比策略模式的类型会发现和状态模式的类图很类似，但实际上有很大的区别，具体体现在concrete class上。策略模式通过Context产生唯一一个ConcreteStrategy作用于代码中，而状态模式则是通过context组织多个ConcreteState形成一个状态转换图来实现业务逻辑。接下来，我们通过一段通用代码来解释怎么使用状态模式：

```java
//定义一个抽象的状态类
public abstract class State {
    Context context;
    public void setContext(Context context) {
        this.context = context;
    }
    public abstract void handle1();
    public abstract void handle2();
}
//定义状态A
public class ConcreteStateA extends State {
    @Override
    public void handle1() {}  //本状态下必须要处理的事情

    @Override
    public void handle2() {
        super.context.setCurrentState(Context.contreteStateB);  //切换到状态B        
        super.context.handle2();  //执行状态B的任务
    }
}
//定义状态B
public class ConcreteStateB extends State {
    @Override
    public void handle2() {}  //本状态下必须要处理的事情，...
  
    @Override
    public void handle1() {
        super.context.setCurrentState(Context.contreteStateA);  //切换到状态A
        super.context.handle1();  //执行状态A的任务
    }
}
//定义一个上下文管理环境
public class Context {
    public final static ConcreteStateA contreteStateA = new ConcreteStateA();
    public final static ConcreteStateB contreteStateB = new ConcreteStateB();

    private State CurrentState;
    public State getCurrentState() {return CurrentState;}

    public void setCurrentState(State currentState) {
        this.CurrentState = currentState;
        this.CurrentState.setContext(this);
    }
    public void handle1() {this.CurrentState.handle1();}
    public void handle2() {this.CurrentState.handle2();}
}
//定义client执行
public class client {
    public static void main(String[] args) {
        Context context = new Context();
        context.setCurrentState(new ContreteStateA());
        context.handle1();
        context.handle2();
    }
}
```



## 建造者

## 代理

代理模式(Proxy Design Pattern)的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。我们通过一个简单的例子来解释一下这段话。





## 装饰器

## 适配器

## 观察者

## 模板

## 迭代器

## 职责链

### 案例一：

责任链模式用于在软件设计中实现松散耦合，其中来自客户端的请求被传递到对象链以处理它们。稍后，链中的对象将自行决定由谁来处理请求，以及是否需要将请求发送到链中的下一个对象。

#### **JDK 中的责任链模式示例**

让我们看看 JDK 中责任链模式的例子，然后我们将继续实现这个模式的真实例子。我们知道在一个 try-catch 块代码中可以有多个 catch 块。这里的每个 catch 块都是处理该特定异常的处理器。

因此，当 try 块中发生任何异常时，将其发送到第一个 catch 块进行处理。如果 catch 块无法处理它，它将请求转发到链中的下一个对象，即下一个 catch 块。如果即使是最后一个 catch 块也无法处理它，则异常会被抛出到调用程序的链外。

#### **责任链设计模式示例**

责任链模式的一个很好的例子是ATM机出钞机。用户输入要发放的金额，机器就会按规定的货币票据发放金额，如50元、20元、10元等。

如果用户输入的金额不是10的倍数，就会出错。我们将使用责任链模式来实现这个解决方案。该链将按照以下图片的顺序处理请求

![Chain of Responsibility Pattern, Chain of Responsibility Design Pattern](设计模式.assets/Chain-of-Responsibility-Pattern-450x435.png-1637659981023.webp)

请注意，我们可以很容易地在一个程序本身中实现这个解决方案，但这样一来，复杂性就会增加，解决方案就会被紧密地耦合起来。因此，我们将创建一个分配系统链，分配50元、20元和10元的钞票。

#### 责任链设计模式——基类和接口

```java
public class Currency {

	private int amount;
	
	public Currency(int amt){
		this.amount=amt;
	}
	
	public int getAmount(){
		return this.amount;
	}
}
```

基础接口应该有一个方法来定义链上的下一个处理器，以及处理请求的方法。我们的ATM配给接口将看起来像下面这样

```java
public interface DispenseChain {

	void setNextChain(DispenseChain nextChain);
	
	void dispense(Currency cur);
}
```



##### 责任链模式--链式实现

我们需要创建不同的处理器类，它们将实现DispenseChain接口并提供dispense方法的实现。由于我们开发的系统要处理三种类型的货币钞票--50美元、20美元和10美元，我们将创建三个具体的实现。

```java
public class Dollar50Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 50){
			int num = cur.getAmount()/50;
			int remainder = cur.getAmount() % 50;
			System.out.println("Dispensing "+num+" 50$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}
```

```java
public class Dollar20Dispenser implements DispenseChain{

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 20){
			int num = cur.getAmount()/20;
			int remainder = cur.getAmount() % 20;
			System.out.println("Dispensing "+num+" 20$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}
```

```java
public class Dollar10Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 10){
			int num = cur.getAmount()/10;
			int remainder = cur.getAmount() % 10;
			System.out.println("Dispensing "+num+" 10$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}
```

这里需要注意的重要一点是dispense方法的实现。你会注意到，每一个实现都在试图处理请求，根据金额，它可能会处理部分或全部的请求。

如果其中一个链不能完全处理它，它将请求发送到链上的下一个处理器来处理剩余的请求。如果该处理器不能处理任何东西，它只是将相同的请求转发给下一个链。

责任链设计模式——创建链

这是一个非常重要的步骤，我们应该仔细地创建链，否则一个处理器可能根本就得不到任何请求。例如，在我们的实现中，如果我们将第一个处理器链保持为Dollar10Dispenser，然后是Dollar20Dispenser，那么请求将永远不会被转发到第二个处理器，这个链将变得毫无意义。

下面是我们处理用户请求金额的ATM机的实现。

```java
public class ATMDispenseChain {

	private DispenseChain c1;

	public ATMDispenseChain() {
		// initialize the chain
		this.c1 = new Dollar50Dispenser();
		DispenseChain c2 = new Dollar20Dispenser();
		DispenseChain c3 = new Dollar10Dispenser();

		// set the chain of responsibility
		c1.setNextChain(c2);
		c2.setNextChain(c3);
	}

	public static void main(String[] args) {
		ATMDispenseChain atmDispenser = new ATMDispenseChain();
		while (true) {
			int amount = 0;
			System.out.println("Enter amount to dispense");
			Scanner input = new Scanner(System.in);
			amount = input.nextInt();
			if (amount % 10 != 0) {
				System.out.println("Amount should be in multiple of 10s.");
				return;
			}
			// process the request
			atmDispenser.c1.dispense(new Currency(amount));
		}

	}

}
```

我们运行上面的应用程序时，我们得到如下输出。

```java

Enter amount to dispense
530
Dispensing 10 50$ note
Dispensing 1 20$ note
Dispensing 1 10$ note
Enter amount to dispense
100
Dispensing 2 50$ note
Enter amount to dispense
120
Dispensing 2 50$ note
Dispensing 1 20$ note
Enter amount to dispense
15
Amount should be in multiple of 10s.
```

##### 责任链设计模式类图

我们的责任链设计模式实现的 ATM 分配示例如下图所示。

![Chain of Responsibility, Chain of Responsibility Design Pattern, Chain of Responsibility Pattern Class Diagram](设计模式.assets/Chain-of-Responsibility-Class-Diagram-450x266.png.webp)

责任链设计模式要点

客户端不知道链的哪一部分将处理请求，它将把请求发送给链中的第一个对象。例如，在我们的程序中，ATMDispenseChain不知道谁在处理发放输入金额的请求。

链上的每个对象都有自己的实现来处理请求，可以是全部或部分，也可以是将其发送到链上的下一个对象。

链中的每个对象都应该有对链中下一个对象的引用来转发请求，这是由java组合实现的。

仔细创建链是非常重要的，否则可能会出现这样的情况：请求永远不会被转发到某个特定的处理器，或者链中没有能够处理该请求的对象。在我的实现中，我已经添加了对用户输入的金额的检查，以确保它被所有的处理器完全处理，但如果请求到达最后一个对象，而链中没有其他对象可以转发请求，我们可能不会检查它并抛出异常。这是一个设计决定。

责任链设计模式对于实现无耦合性是很好的，但它也有一个代价，那就是有很多实现类，如果大部分代码在所有的实现中都是通用的，就会出现维护问题。



#### **责任链模式何时何地适用：** 


- 当您想解耦请求的发送者和接收者时
- 在运行时确定的多个对象是处理请求的候选对象
- 当您不想在代码中显式指定处理程序时
- 当您想向多个对象之一发出请求而不明确指定接收者时。

当多个对象可以处理一个请求并且处理程序不必是特定对象时，建议使用此模式。此外，处理程序是在运行时确定的。请注意，任何处理程序根本没有处理的请求是一个有效的用例。


![img](设计模式.assets/desigmpatternuml1.png)

 

- **处理程序：**这可以是一个接口，主要接收请求并将请求分派到处理程序链。它仅引用链中的第一个处理程序，并且对其余处理程序一无所知。
- **具体处理程序：**这些是按某种顺序链接的请求的实际处理程序。
- **Client :**请求的发起者，这将访问处理程序来处理它。

**如何使用责任链在应用程序中发送请求**

需要处理请求的客户端将其发送到处理程序链，这些处理程序是扩展 Handler 类的类。 
链中的每个处理程序都轮流尝试处理从客户端收到的请求。 
如果 ConcreteHandler1 可以处理它，则处理该请求，如果不能，则将其发送到处理程序 ConcreteHandler2，即链中的下一个处理程序。

### 案例二

#### **让我们看一个责任链设计模式的例子：**

我们通过一段比较通用的代码来解释如何使用责任链模式：

```java
//定义一个抽象的handle
public abstract class Handler {
    private Handler nextHandler;  //指向下一个处理者
    private int level;  //处理者能够处理的级别

    public Handler(int level) {
        this.level = level;
    }

    public void setNextHandler(Handler handler) {
        this.nextHandler = handler;
    }

    // 处理请求传递，注意final，子类不可重写
    public final void handleMessage(Request request) {
        if (level == request.getRequstLevel()) {
            this.echo(request);
        } else {
            if (this.nextHandler != null) {
                this.nextHandler.handleMessage(request);
            } else {
                System.out.println("已经到最尽头了");
            }
        }
    }
    // 抽象方法，子类实现
    public abstract void echo(Request request);
}

// 定义一个具体的handleA
public class HandleRuleA extends Handler {
    public HandleRuleA(int level) {
        super(level);
    }
    @Override
    public void echo(Request request) {
        System.out.println("我是处理者1,我正在处理A规则");
    }
}

//定义一个具体的handleB
public class HandleRuleB extends Handler {}  //...

//客户端实现
class Client {
    public static void main(String[] args) {
        HandleRuleA handleRuleA = new HandleRuleA(1);
        HandleRuleB handleRuleB = new HandleRuleB(2);
        handleRuleA.setNextHandler(handleRuleB);  //这是重点，将handleA和handleB串起来
        handleRuleA.echo(new Request());
    }
}
```

示例2：

在实际开发中，经常避免不了会与其他公司进行接口对接，绝大部分请求参数都是经过加密处理再发送到互联网上，下面我们以对请求参数进行验证、封装处理为例，来诠释责任链模式的玩法，实现过程如下！

- 我们先编写一个加密工具类，采用AES加密算法

```java
public class AESUtil {

    private static Logger log = LoggerFactory.getLogger(AESUtil.class);

    private static final String AES = "AES";

    private static final String AES_CVC_PKC = "AES/CBC/PKCS7Padding";

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    /**
     * 加密
     * @param content
     * @param key
     * @return
     * @throws Exception
     */
    public static String encrypt(String content, String key) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), AES);
            Cipher cipher = Cipher.getInstance(AES_CVC_PKC);
            IvParameterSpec iv = new IvParameterSpec(new byte[16]);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);
            byte[] encrypted = cipher.doFinal(content.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        }  catch (Exception e) {
            log.warn("AES加密失败,参数:{}，错误信息:{}", content, ExceptionUtils.getStackTrace(e));
            return "";
        }
    }

    /**
     * 解密
     * @param content
     * @param key
     * @return
     * @throws Exception
     */
    public static String decrypt(String content, String key) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), AES);
            Cipher cipher = Cipher.getInstance(AES_CVC_PKC);
            IvParameterSpec iv = new IvParameterSpec(new byte[16]);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, iv);
            byte[] encrypted = Base64.getDecoder().decode(content);
            byte[] original = cipher.doFinal(encrypted);
            return new String(original, "UTF-8");
        } catch (Exception e) {
            log.warn("AES解密失败,参数:{}，错误信息:{}", content, ExceptionUtils.getStackTrace(e));
            return "";
        }
    }

​```java
public class Chain
{
Processor chain;
  
public Chain(){
    buildChain();
}
  
private void buildChain(){
    chain = new NegativeProcessor(new ZeroProcessor(new PositiveProcessor(null)));
}
  
public void process(Number request) {
    chain.process(request);
}
  
}
  
abstract class Processor 
{ 
    private Processor processor;
  
    public Processor(Processor processor){
        this.processor = processor;
    };
      
    public void process(Number request){
        if(processor != null)
            processor.process(request);
    }; 
} 
  
class Number 
{ 
    private int number; 
  
    public Number(int number) 
    { 
        this.number = number; 
    } 
  
    public int getNumber() 
    { 
        return number; 
    } 
  
} 
  
class NegativeProcessor extends Processor 
{ 
    public NegativeProcessor(Processor processor){
        super(processor);
          
    }
  
    public void process(Number request) 
    { 
        if (request.getNumber() < 0) 
        { 
            System.out.println("NegativeProcessor : " + request.getNumber()); 
        } 
        else
        { 
            super.process(request); 
        } 
    } 
} 
  
class ZeroProcessor extends Processor 
{ 
    public ZeroProcessor(Processor processor){
        super(processor);
    }
  
    public void process(Number request) 
    { 
        if (request.getNumber() == 0) 
        { 
            System.out.println("ZeroProcessor : " + request.getNumber()); 
        } 
        else
        { 
            super.process(request); 
        } 
    } 
} 
  
class PositiveProcessor extends Processor 
{ 
  
    public PositiveProcessor(Processor processor){
        super(processor);
    }
  
    public void process(Number request) 
    { 
        if (request.getNumber() > 0) 
        { 
            System.out.println("PositiveProcessor : " + request.getNumber()); 
        } 
        else
        { 
            super.process(request); 
        } 
    } 
} 
  
class TestChain 
{ 
    public static void main(String[] args) { 
        Chain chain = new Chain();
          
        //Calling chain of responsibility 
        chain.process(new Number(90)); 
        chain.process(new Number(-50)); 
        chain.process(new Number(0)); 
        chain.process(new Number(91)); 
    } 
} 
```

输出：

```
正处理器：90
负处理器：-50
零处理器：0
正处理器：91
```



- 降低耦合度。解耦它将请求发送方和接收方。
- 简化的对象。对象不需要知道链结构。
- 增强对象分配职责的灵活性。通过更改链内成员或更改其顺序，允许动态添加或删除职责。
- 增加非常方便的请求处理新类。

**责任链设计模式的缺点**


- 必须收到请求而不是保证。
- 系统的性能会受到影响，而且在代码调试不方便可能会造成循环调用。
- 由于调试，可能不容易观察操作特性。

    public static void main(String[] args) throws Exception {
        String key = "1234567890123456";
        String content = "{\"userCode\":\"zhangsan\",\"userPwd\":\"123456\"}";
        String encryptContext = encrypt(content, "1234567890123456");
        System.out.println("加密后的内容：" + encryptContext);
        String decryptContext = decrypt(encryptContext, key);
        System.out.println("解密后的内容：" + decryptContext);
    }

}
```

执行结果如下：

​```java
加密后的内容：5ELORDsYKxCz6Ec377udct7dBMI74ZtJDCFL4B3cpoBsPC8ILH/aiaRFnZa/oTC5
解密后的内容：{"userCode":"zhangsan","userPwd":"123456"}
```

其中加密后的内容可以看作为请求者传过来的参数！

- 同时，再创建一个上下文实体类`ServiceContext`，用于数据记录

```java
/**
 * 上下文
 */
public class ServiceContext {

    /**
     * 请求参数
     */
    private String requestParam;

    /**
     * 解密后的数据
     */
    private String jsonData;

    /**
     * 用户账号
     */
    private String userCode;

    /**
     * 用户密码
     */
    private String userPwd;

    //省略set\get

    public ServiceContext() {
    }

    public ServiceContext(String requestParam) {
        this.requestParam = requestParam;
    }
}
```

- 然后，创建一个处理器接口`HandleIntercept`

```java
public interface HandleIntercept {

    /**
     * 对参数进行处理
     * @param context
     * @return
     */
    ServiceContext handle(ServiceContext context);

}
```

- 紧接着，创建两个处理器实现类，用于参数解密、业务数据验证

```java
/**
 * 解密请求数据
 */
public class DecodeDataHandle implements HandleIntercept {

    private String key = "1234567890123456";

    @Override
    public ServiceContext handle(ServiceContext context) {
        String jsonData = AESUtil.decrypt(context.getRequestParam(), key);
        if(StringUtils.isEmpty(jsonData)){
            throw new IllegalArgumentException("解密失败");
        }
        context.setJsonData(jsonData);
        return context;
    }
}
/**
 * 验证业务数据并封装
 */
public class ValidDataHandle implements HandleIntercept {

    @Override
    public ServiceContext handle(ServiceContext context) {
        String jsonData = context.getJsonData();
        JSONObject jsonObject = JSONObject.parseObject(jsonData);
        if(!jsonObject.containsKey("userCode")){
            throw new IllegalArgumentException("userCode不能为空");
        }
        context.setUserCode(jsonObject.getString("userCode"));
        if(!jsonObject.containsKey("userPwd")){
            throw new IllegalArgumentException("userPwd不能为空");
        }
        context.setUserPwd(jsonObject.getString("userPwd"));
        return context;
    }
}
```

- 最后创建一个处理链路管理器`HandleChain`

```java
/**
 * 请求处理链路管理器
 */
public class HandleChain {
    
    private List<HandleIntercept> handleInterceptList = new ArrayList<>();

    /**
     * 添加处理器
     * @param handleIntercept
     */
    public void addHandle(HandleIntercept handleIntercept){
        handleInterceptList.add(handleIntercept);
    }

    /**
     * 执行处理
     * @param context
     * @return
     */
    public ServiceContext execute(ServiceContext context){
        if(!handleInterceptList.isEmpty()){
            for (HandleIntercept handleIntercept : handleInterceptList) {
                context =handleIntercept.handle(context);
            }
        }
        return context;
    }
}
```

- 写完之后，我们编写一个测试类`ChainClientTest`

```java
public class ChainClientTest {

    public static void main(String[] args) {
        //获取请求参数
        String requestParam = "5ELORDsYKxCz6Ec377udct7dBMI74ZtJDCFL4B3cpoBsPC8ILH/aiaRFnZa/oTC5";
        //封装请求参数
        ServiceContext serviceContext = new ServiceContext(requestParam);

        //添加处理链路
        HandleChain handleChain = new HandleChain();
        handleChain.addHandle(new DecodeDataHandle());//解密处理
        handleChain.addHandle(new ValidDataHandle());//数据验证处理

        //执行处理链,获取处理结果
        serviceContext = handleChain.execute(serviceContext);
        System.out.println("处理结果：" + JSONObject.toJSONString(serviceContext));
    }
}
```

执行之后结果如下：

```json
处理结果：{"jsonData":"{\"userCode\":\"zhangsan\",\"userPwd\":\"123456\"}","requestParam":"5ELORDsYKxCz6Ec377udct7dBMI74ZtJDCFL4B3cpoBsPC8ILH/aiaRFnZa/oTC5","userCode":"zhangsan","userPwd":"123456"}
```

![图片](设计模式.assets/640.webp)

可以很清晰的看到，从请求者发送数据经过处理器链路之后，数据都封装到上下文中去了！

如果想继续验证用户和密码是否合法，可以继续添加新的处理器，即可完成数据的处理验证！

如果是传统的方法，可能就是多个`if`，进行嵌套，类似如下：

```java
if(condition){
    if(condition){
        if(condition){
   //业务处理
        }
    }
}
```

这种模式，最大的弊端就是可读性非常差，而且代码不好维护！

而责任链是从接口层进行封装处理和判断，可扩展性非常强！

### 三、应用

责任链模式的使用场景，这个就不多说了，最典型的就是 Servlet 中的 Filter，有了上面的分析，大家应该也可以理解 Servlet 中责任链模式的工作原理了，然后为什么一个一个的 Filter 需要配置在 web.xml 中，其实本质就是将 filter 注册到处理器中。

```java
public class TestFilter implements Filter{

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        chain.doFilter(request, response);
    }

    public void destroy() {}
    public void init(FilterConfig filterConfig) throws ServletException {}
}
```

## 设计模式在外卖营销业务中的具体案例

https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html

### 邀请下单业务中设计模式的实践

#### 业务简介

“邀请下单”是美团外卖用户邀请其他用户下单后给予奖励的平台。即用户A邀请用户B，并且用户B在美团下单后，给予用户A一定的现金奖励（以下简称返奖）。同时为了协调成本与收益的关系，返奖会有多个计算策略。邀请下单后台主要涉及两个技术要点：

1. 返奖金额的计算，涉及到不同的计算规则。
2. 从邀请开始到返奖结束的整个流程。

![img](设计模式.assets/063d87dacbe6fe4378fe5abf35b452271270612.png)

#### 返奖规则与设计模式实践

##### 业务建模

##### 如图是返奖规则计算的业务逻辑视图：

![img](设计模式.assets/bbdae7e0dd7e4ac64224a96f92977ff5127700.png)

从这份业务逻辑图中可以看到返奖金额计算的规则。首先要根据用户状态确定用户是否满足返奖条件。如果满足返奖条件，则继续判断当前用户属于新用户还是老用户，从而给予不同的奖励方案。一共涉及以下几种不同的奖励方案：

**新用户**

- 普通奖励（给予固定金额的奖励）
- 梯度奖（根据用户邀请的人数给予不同的奖励金额，邀请的人越多，奖励金额越多）

**老用户**

- 根据老用户的用户属性来计算返奖金额。为了评估不同的邀新效果，老用户返奖会存在多种返奖机制。

计算完奖励金额以后，还需要更新用户的奖金信息，以及通知结算服务对用户的金额进行结算。这两个模块对于所有的奖励来说都是一样的。

可以看到，无论是何种用户，对于整体返奖流程是不变的，唯一变化的是返奖规则。此处，我们可参考**开闭原则**，对于返奖流程保持封闭，对于可能扩展的返奖规则进行开放。我们将返奖规则抽象为**返奖策略**，即针对不同用户类型的不同返奖方案，我们视为不同的返奖策略，不同的返奖策略会产生不同的返奖金额结果。

在我们的领域模型里，返奖策略是一个**值对象**，我们通过工厂的方式生产针对不同用户的奖励策略值对象。下文我们将介绍以上领域模型的工程实现，即**工厂模式**和**策略模式**的实际应用。

##### 工程实践

通过上文介绍的返奖业务模型，我们可以看到返奖的主流程就是选择不同的返奖策略的过程，每个返奖策略都包括返奖金额计算、更新用户奖金信息、以及结算这三个步骤。 我们可以使用工厂模式生产出不同的策略，同时使用策略模式来进行不同的策略执行。首先确定我们需要生成出n种不同的返奖策略，其编码如下：

```java
//抽象策略
public abstract class RewardStrategy {
    public abstract void reward(long userId);
  
    public void insertRewardAndSettlement(long userId, int reward) {} ; //更新用户信息以及结算
}

//新用户返奖具体策略A
public class newUserRewardStrategyA extends RewardStrategy {
    @Override
    public void reward(long userId) {}  //具体的计算逻辑，...
}

//老用户返奖具体策略A
public class OldUserRewardStrategyA extends RewardStrategy {
    @Override
    public void reward(long userId) {}  //具体的计算逻辑，...
}

//抽象工厂
public abstract class StrategyFactory<T> {
    abstract RewardStrategy createStrategy(Class<T> c);
}

//具体工厂创建具体的策略
public class FactorRewardStrategyFactory extends StrategyFactory {
    @Override
    RewardStrategy createStrategy(Class c) {
        RewardStrategy product = null;
        try {
            product = (RewardStrategy) Class.forName(c.getName()).newInstance();
        } catch (Exception e) {}
        return product;
    }
}
```

通过工厂模式生产出具体的策略之后，根据我们之前的介绍，很容易就可以想到使用策略模式来执行我们的策略。具体代码如下：

```java
public class RewardContext {
    private RewardStrategy strategy;

    public RewardContext(RewardStrategy strategy) {
        this.strategy = strategy;
    }

    public void doStrategy(long userId) { 
        int rewardMoney = strategy.reward(userId);
        insertRewardAndSettlement(long userId, int reward) {
          insertReward(userId, rewardMoney);
          settlement(userId);
       }  
    }
}
```

接下来我们将工厂模式和策略模式结合在一起，就完成了整个返奖的过程：

```java
public class InviteRewardImpl {
    //返奖主流程
    public void sendReward(long userId) {
        FactorRewardStrategyFactory strategyFactory = new FactorRewardStrategyFactory();  //创建工厂
        Invitee invitee = getInviteeByUserId(userId);  //根据用户id查询用户信息
        if (invitee.userType == UserTypeEnum.NEW_USER) {  //新用户返奖策略
            NewUserBasicReward newUserBasicReward = (NewUserBasicReward) strategyFactory.createStrategy(NewUserBasicReward.class);
            RewardContext rewardContext = new RewardContext(newUserBasicReward);
            rewardContext.doStrategy(userId); //执行返奖策略
        }if(invitee.userType == UserTypeEnum.OLD_USER){}  //老用户返奖策略，... 
    }
}
```

工厂方法模式帮助我们直接产生一个具体的策略对象，策略模式帮助我们保证这些策略对象可以自由地切换而不需要改动其他逻辑，从而达到解耦的目的。通过这两个模式的组合，当我们系统需要增加一种返奖策略时，只需要实现RewardStrategy接口即可，无需考虑其他的改动。当我们需要改变策略时，只要修改策略的类名即可。不仅增强了系统的可扩展性，避免了大量的条件判断，而且从真正意义上达到了高内聚、低耦合的目的。

#### 返奖流程与设计模式实践

##### 业务建模

当受邀人在接受邀请人的邀请并且下单后，返奖后台接收到受邀人的下单记录，此时邀请人也进入返奖流程。首先我们订阅用户订单消息并对订单进行返奖规则校验。例如，是否使用红包下单，是否在红包有效期内下单，订单是否满足一定的优惠金额等等条件。当满足这些条件以后，我们将订单信息放入延迟队列中进行后续处理。经过T+N天之后处理该延迟消息，判断用户是否对该订单进行了退款，如果未退款，对用户进行返奖。若返奖失败，后台还有返奖补偿流程，再次进行返奖。其流程如下图所示

![img](设计模式.assets/9451d00f5afdcd0b965edd4c0df2c78775861.png)

我们对上述业务流程进行领域建模：

1. 在接收到订单消息后，用户进入待校验状态；
2. 在校验后，若校验通过，用户进入预返奖状态，并放入延迟队列。若校验未通过，用户进入不返奖状态，结束流程；
3. T+N天后，处理延迟消息，若用户未退款，进入待返奖状态。若用户退款，进入失败状态，结束流程；
4. 执行返奖，若返奖成功，进入完成状态，结束流程。若返奖不成功，进入待补偿状态；
5. 待补偿状态的用户会由任务定期触发补偿机制，直至返奖成功，进入完成状态，保障流程结束。



![img](设计模式.assets/39c2a0540c5eaab78f10ac362594681a53146.png)

可以看到，我们通过建模将返奖流程的多个步骤映射为系统的状态。对于系统状态的表述，DDD中常用到的概念是领域事件，另外也提及过事件溯源的实践方案。当然，在设计模式中，也有一种能够表述系统状态的代码模型，那就是状态模式。在邀请下单系统中，我们的主要流程是返奖。对于返奖，每一个状态要进行的动作和操作都是不同的。因此，使用状态模式，能够帮助我们对系统状态以及状态间的流转进行统一的管理和扩展。

##### 工程实践

```java
//返奖状态执行的上下文
public class RewardStateContext {

    private RewardState rewardState;
  
    public void setRewardState(RewardState currentState) {this.rewardState = currentState;}
    public RewardState getRewardState() {return rewardState;}
    public void echo(RewardStateContext context, Request request) {
        rewardState.doReward(context, request);
    }
}

public abstract class RewardState {
    abstract void doReward(RewardStateContext context, Request request);
}

//待校验状态
public class OrderCheckState extends RewardState {
    @Override
    public void doReward(RewardStateContext context, Request request) {
        orderCheck(context, request);  //对进来的订单进行校验，判断是否用券，是否满足优惠条件等等
    }
}

//待补偿状态
public class CompensateRewardState extends RewardState {
    @Override
    public void doReward(RewardStateContext context, Request request) {
        compensateReward(context, request);  //返奖失败，需要对用户进行返奖补偿
    }
}
​
//预返奖状态，待返奖状态，成功状态，失败状态(此处逻辑省略)
//..

public class InviteRewardServiceImpl {
    public boolean sendRewardForInvtee(long userId, long orderId) {
        Request request = new Request(userId, orderId);
        RewardStateContext rewardContext = new RewardStateContext();
        rewardContext.setRewardState(new OrderCheckState());
        rewardContext.echo(rewardContext, request);  //开始返奖，订单校验
        //此处的if-else逻辑只是为了表达状态的转换过程，并非实际的业务逻辑
        if (rewardContext.isResultFlag()) {  //如果订单校验成功，进入预返奖状态
            rewardContext.setRewardState(new BeforeRewardCheckState());
            rewardContext.echo(rewardContext, request);
        } else {//如果订单校验失败，进入返奖失败流程，...
            rewardContext.setRewardState(new RewardFailedState());
            rewardContext.echo(rewardContext, request);
            return false;
        }
        if (rewardContext.isResultFlag()) {//预返奖检查成功，进入待返奖流程，...
            rewardContext.setRewardState(new SendRewardState());
            rewardContext.echo(rewardContext, request);
        } else {  //如果预返奖检查失败，进入返奖失败流程，...
            rewardContext.setRewardState(new RewardFailedState());
            rewardContext.echo(rewardContext, request);
            return false;
        }
        if (rewardContext.isResultFlag()) {  //返奖成功，进入返奖结束流程，...
            rewardContext.setRewardState(new RewardSuccessState());
            rewardContext.echo(rewardContext, request);
        } else {  //返奖失败，进入返奖补偿阶段，...
            rewardContext.setRewardState(new CompensateRewardState());
            rewardContext.echo(rewardContext, request);
        }
        if (rewardContext.isResultFlag()) {  //补偿成功，进入返奖完成阶段，...
            rewardContext.setRewardState(new RewardSuccessState());
            rewardContext.echo(rewardContext, request);
        } else {  //补偿失败，仍然停留在当前态，直至补偿成功（或多次补偿失败后人工介入处理）
            rewardContext.setRewardState(new CompensateRewardState());
            rewardContext.echo(rewardContext, request);
        }
        return true;
    }
}
```

状态模式的核心是封装，将状态以及状态转换逻辑封装到类的内部来实现，也很好的体现了“开闭原则”和“单一职责原则”。每一个状态都是一个子类，不管是修改还是增加状态，只需要修改或者增加一个子类即可。在我们的应用场景中，状态数量以及状态转换远比上述例子复杂，通过“状态模式”避免了大量的if-else代码，让我们的逻辑变得更加清晰。同时由于状态模式的良好的封装性以及遵循的设计原则，让我们在复杂的业务场景中，能够游刃有余地管理各个状态。

