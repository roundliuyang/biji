## 单例

## 工厂

### 抽象工厂



### 工厂方法

**模式定义**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类。

![](https://p0.meituan.net/travelcube/653ab8f2224eaf4c392b59cae96c30d440308.png)

我们通过一段较为通用的代码来解释如何使用工厂模式：

```java
//抽象的产品
public abstract class Product {
    public abstract void method();
}
//定义一个具体的产品 (可以定义多个具体的产品)
class ProductA extends Product {
    @Override
    public void method() {}  //具体的执行逻辑
}
//抽象的工厂
abstract class Factory<T> {
    abstract Product createProduct(Class<T> c);
}
//具体的工厂可以生产出相应的产品
class FactoryA extends Factory{
    @Override
    Product createProduct(Class c) {
        Product product = (Product) Class.forName(c.getName()).newInstance();
        return product;
    }
}
```

## 策略

模式定义：定义一系列算法，将每个算法都封装起来，并且它们可以互换。策略模式是一种对象行为模式。

策略模式通用类图如下:

![](https://p0.meituan.net/travelcube/a2282c7a7cef61e35d29db6bd27c824034361.png)

我们通过一段比较通用的代码来解释怎么使用策略模式：

```java
//定义一个策略接口
public interface Strategy {
    void strategyImplementation();
}

//具体的策略实现(可以定义多个具体的策略实现)
public class StrategyA implements Strategy{
    @Override
    public void strategyImplementation() {
        System.out.println("正在执行策略A");
    }
}

//封装策略，屏蔽高层模块对策略、算法的直接访问，屏蔽可能存在的策略变化
public class Context {
    private Strategy strategy = null;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
  
    public void doStrategy() {
        strategy.strategyImplementation();
    }
}
```

## 策略模式和工厂模式的工程实践：

[1]: https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html	"设计模式在外卖营销业务中的实践"

## 状态模式

**模式定义**：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。

状态模式的通用类图如下图所示：

![](https://p0.meituan.net/travelcube/75e091982ed46532e674419ddfffb4cb40964.png)

对比策略模式的类型会发现和状态模式的类图很类似，但实际上有很大的区别，具体体现在concrete class上。策略模式通过Context产生唯一一个ConcreteStrategy作用于代码中，而状态模式则是通过context组织多个ConcreteState形成一个状态转换图来实现业务逻辑。接下来，我们通过一段通用代码来解释怎么使用状态模式：

```java
//定义一个抽象的状态类
public abstract class State {
    Context context;
    public void setContext(Context context) {
        this.context = context;
    }
    public abstract void handle1();
    public abstract void handle2();
}
//定义状态A
public class ConcreteStateA extends State {
    @Override
    public void handle1() {}  //本状态下必须要处理的事情
​
    @Override
    public void handle2() {
        super.context.setCurrentState(Context.contreteStateB);  //切换到状态B        
        super.context.handle2();  //执行状态B的任务
    }
}
//定义状态B
public class ConcreteStateB extends State {
    @Override
    public void handle2() {}  //本状态下必须要处理的事情，...
  
    @Override
    public void handle1() {
        super.context.setCurrentState(Context.contreteStateA);  //切换到状态A
        super.context.handle1();  //执行状态A的任务
    }
}
//定义一个上下文管理环境
public class Context {
    public final static ConcreteStateA contreteStateA = new ConcreteStateA();
    public final static ConcreteStateB contreteStateB = new ConcreteStateB();

    private State CurrentState;
    public State getCurrentState() {return CurrentState;}

    public void setCurrentState(State currentState) {
        this.CurrentState = currentState;
        this.CurrentState.setContext(this);
    }
    public void handle1() {this.CurrentState.handle1();}
    public void handle2() {this.CurrentState.handle2();}
}
//定义client执行
public class client {
    public static void main(String[] args) {
        Context context = new Context();
        context.setCurrentState(new ContreteStateA());
        context.handle1();
        context.handle2();
    }
}
```

## 状态模式的工程实践：

[1]: https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html	"设计模式在外卖营销业务中的实践"

## 建造者

## 代理

代理模式(Proxy Design Pattern)的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。我们通过一个简单的例子来解释一下这段话。





## 装饰器

## 适配器

## 观察者

## 模板

## 迭代器

## 职责链

责任链模式用于在软件设计中实现松散耦合，其中来自客户端的请求被传递到对象链以处理它们。稍后，链中的对象将自行决定由谁来处理请求，以及是否需要将请求发送到链中的下一个对象。
**责任链模式何时何地适用：** 


- 当您想解耦请求的发送者和接收者时
- 在运行时确定的多个对象是处理请求的候选对象
- 当您不想在代码中显式指定处理程序时
- 当您想向多个对象之一发出请求而不明确指定接收者时。

当多个对象可以处理一个请求并且处理程序不必是特定对象时，建议使用此模式。此外，处理程序是在运行时确定的。请注意，任何处理程序根本没有处理的请求是一个有效的用例。


![img](设计模式.assets/desigmpatternuml1.png)

 

- **处理程序：**这可以是一个接口，主要接收请求并将请求分派到处理程序链。它仅引用链中的第一个处理程序，并且对其余处理程序一无所知。
- **具体处理程序：**这些是按某种顺序链接的请求的实际处理程序。
- **Client :**请求的发起者，这将访问处理程序来处理它。

**如何使用责任链在应用程序中发送请求**

需要处理请求的客户端将其发送到处理程序链，这些处理程序是扩展 Handler 类的类。 
链中的每个处理程序都轮流尝试处理从客户端收到的请求。 
如果 ConcreteHandler1 可以处理它，则处理该请求，如果不能，则将其发送到处理程序 ConcreteHandler2，即链中的下一个处理程序。

**让我们看一个责任链设计模式的例子：**

示例1：

示例1：

我们通过一段比较通用的代码来解释如何使用责任链模式：

```java
//定义一个抽象的handle
public abstract class Handler {
    private Handler nextHandler;  //指向下一个处理者
    private int level;  //处理者能够处理的级别

    public Handler(int level) {
        this.level = level;
    }

    public void setNextHandler(Handler handler) {
        this.nextHandler = handler;
    }

    // 处理请求传递，注意final，子类不可重写
    public final void handleMessage(Request request) {
        if (level == request.getRequstLevel()) {
            this.echo(request);
        } else {
            if (this.nextHandler != null) {
                this.nextHandler.handleMessage(request);
            } else {
                System.out.println("已经到最尽头了");
            }
        }
    }
    // 抽象方法，子类实现
    public abstract void echo(Request request);
}

// 定义一个具体的handleA
public class HandleRuleA extends Handler {
    public HandleRuleA(int level) {
        super(level);
    }
    @Override
    public void echo(Request request) {
        System.out.println("我是处理者1,我正在处理A规则");
    }
}

//定义一个具体的handleB
public class HandleRuleB extends Handler {}  //...

//客户端实现
class Client {
    public static void main(String[] args) {
        HandleRuleA handleRuleA = new HandleRuleA(1);
        HandleRuleB handleRuleB = new HandleRuleB(2);
        handleRuleA.setNextHandler(handleRuleB);  //这是重点，将handleA和handleB串起来
        handleRuleA.echo(new Request());
    }
}
```

示例2：

在实际开发中，经常避免不了会与其他公司进行接口对接，绝大部分请求参数都是经过加密处理再发送到互联网上，下面我们以对请求参数进行验证、封装处理为例，来诠释责任链模式的玩法，实现过程如下！

- 我们先编写一个加密工具类，采用AES加密算法

```java
public class AESUtil {

    private static Logger log = LoggerFactory.getLogger(AESUtil.class);

    private static final String AES = "AES";

    private static final String AES_CVC_PKC = "AES/CBC/PKCS7Padding";

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    /**
     * 加密
     * @param content
     * @param key
     * @return
     * @throws Exception
     */
    public static String encrypt(String content, String key) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), AES);
            Cipher cipher = Cipher.getInstance(AES_CVC_PKC);
            IvParameterSpec iv = new IvParameterSpec(new byte[16]);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);
            byte[] encrypted = cipher.doFinal(content.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        }  catch (Exception e) {
            log.warn("AES加密失败,参数:{}，错误信息:{}", content, ExceptionUtils.getStackTrace(e));
            return "";
        }
    }

    /**
     * 解密
     * @param content
     * @param key
     * @return
     * @throws Exception
     */
    public static String decrypt(String content, String key) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), AES);
            Cipher cipher = Cipher.getInstance(AES_CVC_PKC);
            IvParameterSpec iv = new IvParameterSpec(new byte[16]);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, iv);
            byte[] encrypted = Base64.getDecoder().decode(content);
            byte[] original = cipher.doFinal(encrypted);
            return new String(original, "UTF-8");
        } catch (Exception e) {
            log.warn("AES解密失败,参数:{}，错误信息:{}", content, ExceptionUtils.getStackTrace(e));
            return "";
        }
    }

```java
public class Chain
{
Processor chain;
  
public Chain(){
    buildChain();
}
  
private void buildChain(){
    chain = new NegativeProcessor(new ZeroProcessor(new PositiveProcessor(null)));
}
  
public void process(Number request) {
    chain.process(request);
}
  
}
  
abstract class Processor 
{ 
    private Processor processor;
  
    public Processor(Processor processor){
        this.processor = processor;
    };
      
    public void process(Number request){
        if(processor != null)
            processor.process(request);
    }; 
} 
  
class Number 
{ 
    private int number; 
  
    public Number(int number) 
    { 
        this.number = number; 
    } 
  
    public int getNumber() 
    { 
        return number; 
    } 
  
} 
  
class NegativeProcessor extends Processor 
{ 
    public NegativeProcessor(Processor processor){
        super(processor);
          
    }
  
    public void process(Number request) 
    { 
        if (request.getNumber() < 0) 
        { 
            System.out.println("NegativeProcessor : " + request.getNumber()); 
        } 
        else
        { 
            super.process(request); 
        } 
    } 
} 
  
class ZeroProcessor extends Processor 
{ 
    public ZeroProcessor(Processor processor){
        super(processor);
    }
  
    public void process(Number request) 
    { 
        if (request.getNumber() == 0) 
        { 
            System.out.println("ZeroProcessor : " + request.getNumber()); 
        } 
        else
        { 
            super.process(request); 
        } 
    } 
} 
  
class PositiveProcessor extends Processor 
{ 
  
    public PositiveProcessor(Processor processor){
        super(processor);
    }
  
    public void process(Number request) 
    { 
        if (request.getNumber() > 0) 
        { 
            System.out.println("PositiveProcessor : " + request.getNumber()); 
        } 
        else
        { 
            super.process(request); 
        } 
    } 
} 
  
class TestChain 
{ 
    public static void main(String[] args) { 
        Chain chain = new Chain();
          
        //Calling chain of responsibility 
        chain.process(new Number(90)); 
        chain.process(new Number(-50)); 
        chain.process(new Number(0)); 
        chain.process(new Number(91)); 
    } 
} 
```

输出：

```
正处理器：90
负处理器：-50
零处理器：0
正处理器：91
```



- 降低耦合度。解耦它将请求发送方和接收方。
- 简化的对象。对象不需要知道链结构。
- 增强对象分配职责的灵活性。通过更改链内成员或更改其顺序，允许动态添加或删除职责。
- 增加非常方便的请求处理新类。

**责任链设计模式的缺点**


- 必须收到请求而不是保证。
- 系统的性能会受到影响，而且在代码调试不方便可能会造成循环调用。
- 由于调试，可能不容易观察操作特性。

    public static void main(String[] args) throws Exception {
        String key = "1234567890123456";
        String content = "{\"userCode\":\"zhangsan\",\"userPwd\":\"123456\"}";
        String encryptContext = encrypt(content, "1234567890123456");
        System.out.println("加密后的内容：" + encryptContext);
        String decryptContext = decrypt(encryptContext, key);
        System.out.println("解密后的内容：" + decryptContext);
    }

}
```

执行结果如下：

```java
加密后的内容：5ELORDsYKxCz6Ec377udct7dBMI74ZtJDCFL4B3cpoBsPC8ILH/aiaRFnZa/oTC5
解密后的内容：{"userCode":"zhangsan","userPwd":"123456"}
```

其中加密后的内容可以看作为请求者传过来的参数！

- 同时，再创建一个上下文实体类`ServiceContext`，用于数据记录

```java
/**
 * 上下文
 */
public class ServiceContext {

    /**
     * 请求参数
     */
    private String requestParam;

    /**
     * 解密后的数据
     */
    private String jsonData;

    /**
     * 用户账号
     */
    private String userCode;

    /**
     * 用户密码
     */
    private String userPwd;

    //省略set\get

    public ServiceContext() {
    }

    public ServiceContext(String requestParam) {
        this.requestParam = requestParam;
    }
}
```

- 然后，创建一个处理器接口`HandleIntercept`

```java
public interface HandleIntercept {

    /**
     * 对参数进行处理
     * @param context
     * @return
     */
    ServiceContext handle(ServiceContext context);

}
```

- 紧接着，创建两个处理器实现类，用于参数解密、业务数据验证

```java
/**
 * 解密请求数据
 */
public class DecodeDataHandle implements HandleIntercept {

    private String key = "1234567890123456";

    @Override
    public ServiceContext handle(ServiceContext context) {
        String jsonData = AESUtil.decrypt(context.getRequestParam(), key);
        if(StringUtils.isEmpty(jsonData)){
            throw new IllegalArgumentException("解密失败");
        }
        context.setJsonData(jsonData);
        return context;
    }
}
/**
 * 验证业务数据并封装
 */
public class ValidDataHandle implements HandleIntercept {

    @Override
    public ServiceContext handle(ServiceContext context) {
        String jsonData = context.getJsonData();
        JSONObject jsonObject = JSONObject.parseObject(jsonData);
        if(!jsonObject.containsKey("userCode")){
            throw new IllegalArgumentException("userCode不能为空");
        }
        context.setUserCode(jsonObject.getString("userCode"));
        if(!jsonObject.containsKey("userPwd")){
            throw new IllegalArgumentException("userPwd不能为空");
        }
        context.setUserPwd(jsonObject.getString("userPwd"));
        return context;
    }
}
```

- 最后创建一个处理链路管理器`HandleChain`

```java
/**
 * 请求处理链路管理器
 */
public class HandleChain {
    
    private List<HandleIntercept> handleInterceptList = new ArrayList<>();

    /**
     * 添加处理器
     * @param handleIntercept
     */
    public void addHandle(HandleIntercept handleIntercept){
        handleInterceptList.add(handleIntercept);
    }

    /**
     * 执行处理
     * @param context
     * @return
     */
    public ServiceContext execute(ServiceContext context){
        if(!handleInterceptList.isEmpty()){
            for (HandleIntercept handleIntercept : handleInterceptList) {
                context =handleIntercept.handle(context);
            }
        }
        return context;
    }
}
```

- 写完之后，我们编写一个测试类`ChainClientTest`

```java
public class ChainClientTest {

    public static void main(String[] args) {
        //获取请求参数
        String requestParam = "5ELORDsYKxCz6Ec377udct7dBMI74ZtJDCFL4B3cpoBsPC8ILH/aiaRFnZa/oTC5";
        //封装请求参数
        ServiceContext serviceContext = new ServiceContext(requestParam);

        //添加处理链路
        HandleChain handleChain = new HandleChain();
        handleChain.addHandle(new DecodeDataHandle());//解密处理
        handleChain.addHandle(new ValidDataHandle());//数据验证处理

        //执行处理链,获取处理结果
        serviceContext = handleChain.execute(serviceContext);
        System.out.println("处理结果：" + JSONObject.toJSONString(serviceContext));
    }
}
```

执行之后结果如下：

```json
处理结果：{"jsonData":"{\"userCode\":\"zhangsan\",\"userPwd\":\"123456\"}","requestParam":"5ELORDsYKxCz6Ec377udct7dBMI74ZtJDCFL4B3cpoBsPC8ILH/aiaRFnZa/oTC5","userCode":"zhangsan","userPwd":"123456"}
```

![图片](设计模式.assets/640.webp)

可以很清晰的看到，从请求者发送数据经过处理器链路之后，数据都封装到上下文中去了！

如果想继续验证用户和密码是否合法，可以继续添加新的处理器，即可完成数据的处理验证！

如果是传统的方法，可能就是多个`if`，进行嵌套，类似如下：

```java
if(condition){
    if(condition){
        if(condition){
   //业务处理
        }
    }
}
```

这种模式，最大的弊端就是可读性非常差，而且代码不好维护！

而责任链是从接口层进行封装处理和判断，可扩展性非常强！

### 三、应用

责任链模式的使用场景，这个就不多说了，最典型的就是 Servlet 中的 Filter，有了上面的分析，大家应该也可以理解 Servlet 中责任链模式的工作原理了，然后为什么一个一个的 Filter 需要配置在 web.xml 中，其实本质就是将 filter 注册到处理器中。

```java
public class TestFilter implements Filter{

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        chain.doFilter(request, response);
    }

    public void destroy() {}
    public void init(FilterConfig filterConfig) throws ServletException {}
}
```

## 责任链模式的工程实践：

[1]: https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html	"设计模式在外卖营销业务中的实践"

