# 1 InnoDB 页结构

## 1.1 简介

数据被划分为若干个页，以页作为磁盘和内存之间交互的基本单位，一般为16KB，且<font color="blue">**页内的物理地址是连续的**</font>。最小记录、最大记录和用户记录，三者为主要数据，其中理论上存储了各个行信息，但实际上是**多个行信息**组合成的一条连续的数据。

假设一个页16KB,如果有1G的空间则存在65535个页，只需要256个二级目录项，16个三级目录，四个四级目录，两个五级目录，1个六级目录，一共279 个额外页空间。279 * 16 = 4464 kb （约等于4MB）。



- **页结构示意**
  <img src="..\..\_img\Snipaste_2020-04-05_13-53-59.png" alt="MySQL页结构" style="zoom: 80%;" />
- **数据存储过程**
  ![Snipaste_2020-04-05_21-59-26](..\..\_img\Snipaste_2020-04-05_21-59-26.png)



## 1.2 行

> <font size="5">**infimum，supremum，User Records**</font>

### 1.2.1 Compact（重要）

#### 1.2.1.1 使用语法

```sql
# 创建语法
CREATE TABLE 表名(
    列的信息
) ROW_FORMAT = 行格式名称
# 修改语法
ALTER TABLE 表名 ROW_FORMAT = 行格式名称
```

#### 1.2.1.2 格式

##### 1.2.1.2.1 简介

- a）结构图：
  ![行格式信息](..\..\_img\行格式信息.png)

- b）示例图：
  ![Snipaste_2020-04-05_20-12-30](..\..\_img\Snipaste_2020-04-05_20-12-30.png)

- c）剖析图：
  ![详解01](..\..\_img\Snipaste_2020-04-05_14-41-03.png)
- 1）**变长字段长度列表**，根据列表长度决定占用字节，如：01 03 04；
  - 2）**NULL 标志位**，如：00；
  - 3）**记录头信息**，固定5个字节，如：00 00 00 10 00；
  - 4）**行ID**，固定6个字节，如：00 00 00 00 05 00；
  - 5）**事务ID**，固定6个字节，如：00 00 00 01 43 11；
  - 6）**回滚指针**，固定7个字节，如：8e 00 00 01 a3 01 10；
  - 7）**列的数据**，根据列数据长度决定占用字节。如：61 61 61 61 62 62 62 63 63 20 20 20 20 20 20 20 20 64；

##### 1.2.1.2.2 结构详解

###### 行的额外信息

- 变长列长度列表

  （把所有变长类型列的长度存放在行记录的开头部位形成一个列表，按照列的顺序<font color="blue">逆序存放</font>。）

  - 真正的数据内容
  - 占用的字节数

- NULL 值列表

  （如果把NULL值都放到记录的真实数据中存储，会很占空间，所以把这些值为NULL的列同一管理，存储到NULL值列表中，可以理解为标记列表。）

- 行头信息（记录头信息）

  **a 结构图：**
  ![记录头信息](..\..\_img\记录头信息.png)

  **b 示例图：**
  ![2020-04-06_113953](..\..\_img\2020-04-06_113953.png)

  - **delete_mask**

    标记当前记录是否被删除，占用1个二进制位，0=存在，1=删除；

  - **min_rec_mask**

    标记该记录是否为B+树的非叶子节点中的最小记录。

  - **heap_no（物理页顺序）**

    当前记录在本页中的位置，是物理页的编号，InnoDB会自动在每个页里加两条记录，这两条记录也成为伪记录或虚拟记录。一个代表最小记录（infimum），一个代表最大记录（supremum）。由于 infimum 和 supremum 各占用1个“位置”，序号为0和1，导致实际插入数据后，从2开始计数。

  - **record_type**

    记录类型，0=普通记录，1=B+树非叶节点记录，2=最小记录，3=最大记录；

  - **next_record（逻辑顺序，<font color="red">主键地址链表</font>）**

    1. 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量；
    2. 下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。
    3. 规定『最小记录』 的下一条记录是本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是『最大记录』；
       <img src="..\..\_img\Snipaste_2020-04-06_11-47-45.png" alt="Snipaste_2020-04-06_11-47-45" style="zoom: 80%;" />

###### 真实数据

> 每条记录都会添加 transaction_id 和 roll_pointer，但 row_id 只有在表没有定义主键的时候才会为记录添加，相当于默认主键。

- **row_id**（非必须）：6 字节，表示行ID，唯一标识一条记录。
- **transaction_id**（必须）：6 字节，表示事务ID。
- **roll_pointer**（必须）：7 字节，回滚指针。

#### 1.2.1.3 Tips

- 如果 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度需要占用2个字节，NULL 值标识需要占用1个字节；如果有 NOT NULL 属性，那最多只能存储 65533 个字节的数据。
- 一个页的大小一般是16KB，也就是16384字节，因此，可能造成1个页存放不下一条记录，则需要多页存储1条记录（会存储一个指向其他页的地址）。

### 1.2.2 Redundant，Dynamic，Compressed

略





## 1.3 页目录

> - <font color="blue">**页目录里存放的单位是槽**</font>
> - <font color="blue">**每个槽代表1组记录**</font>
> - <font color="blue">**定位到某个页后，需要二分查找其中的行时，就需要用到目录。**</font>
> - <font color="blue">**针对数据行而产生的的。**</font>

将所有正常的记录（包括最大最小记录，不包括标记为删除的记录）划分为几个组。

每个组的最后一条记录的头信息中的 n_owned 属性表示该组内公有几条记录。

将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（每个槽会保存到页目录中）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为 Page Directory。

![Snipaste_2020-04-06_14-19-54](..\..\_img\Snipaste_2020-04-06_14-19-54.png)

- 1）初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。

- 2）之后每插入一条记录都把这条记录放到最大记录所在的组，直到最大记录所在的组中的记录数等于8个。

- 3）在最大记录所在组中的记录数等于8个（为什么是8个？）的时候再插入一条记录时，将最大记录锁在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到相应的组中了。

- 4）页目录中的各个槽代表的记录的主键值都是从小到大排序的，所以可以使用二分法来进行快速查找。

- 5）通过记录的 next_record 属性组成的链表遍历查找该槽中的各个记录。

## 1.4 File Header

> 也是描述页的信息，主要作用记录以下数据

- FIL_PAGE_OFFSET：页号
- FIL_PAGE_PREV：上一个页的页号
- FIL_PAGE_NEXT：下一个页的页号（形成双链表结构）
- FIL_PAGE_TYPE：该页的类型
  - FIL_PAGE_TYPE_BLOB：BLOB页
  - FIL_PAGE_INDEX：B+树的子节点



## 1.5 Page Header

- PAGE_N_DIR_SLOTS：在页目录中的槽的数量；
- PAGE_HEAP_TOP：第一个记录的地址；
- PAGE_N_HEAP：本业中的记录的数量（包括最大最小，以及删除的）；
- PAGE_FREE：标记为删除的记录地址；
- PAGE_GARBAGE：已删除的字节数；
- PAGE_LAST_INSERT：最后插入记录的位置；
- PAGE_N_RECS：该页中的记录数量（不包括最大最小，删除记录）；
- PAGE_MAX_TRX_ID：修改当前页的最大事务ID，该值仅在二级索引中定义；
- PAGE_LEVEL：当前页在索引树中的位置，高度；



## 1.6 File Trailer

用于检测一个页是否完整，每个页尾部由8个字节组成一个Trailer。

- 前4个字节代表页的校验和。
- 后4个字节代表日志序列位置（LSN）。



# 2 行迁移

由于页与页之间是递增主键值，则当插入的主键值小于当前记录的最大值，则会伴随一次记录的移动，保证整个链表关系是有小到大的。

- 耗资源，因此推荐使用自增列来控制。



# 3 总结

- InnoDB 数据页由7个部分组成，各个数据页可以组成一个<font color="red">**双向链表**</font>，而每个数据页中的记录又可以组成一个<font color="red">**单向链表**</font>，每个数据页都会为存储在它里面的记录生成一个<font color="red">**页目录**</font>。在通过主键查找某条记录时，可以在页目录中使用二分法快速定位到相应的<font color="red">**槽**</font>，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 下一个数据页中的主键值必须大于上一个页中的主键值。

