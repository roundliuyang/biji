# 1 查找

## 1.1 查找方式

没有索引的查找

- 在一个页中的查找
  - 索引搜索
    - 在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录，最后需要回表则回表。
  - 非索引搜索
    - 在数据页中没有对非主键列建立页目录，所以无法通过二分法快速定位相应的槽。只能从最小记录依次遍历单链表中的每条记录，然后对比每条记录是否符合搜索条件。

- 在多个页中的查找
  - 索引搜索
    - 1）二分法定位页目录
    - 2）二分法定位页
    - 3）二分法定位数据行（最后需要回表则回表）
  - 非索引搜索
    - 1）遍历所有的列
    - 2）定位到记录所在的页
    - 3）在所在的页中查找相应的记录。



## 1.2 目录项（页目录的目录）

> <font color="blue">**针对页而产生的。**</font>

因为这些16KB的页在物理存储上并不连续，所以如果想从这么多页中根据主键快速定位某些记录所在的页，我们需要给他们做个目录，就像为页中的记录建立一个页目录一样，引擎会为所有的页建立一个目录。每个页对应一个目录项。

### 1.2.1 结构

**这里的结构，只指行的数据（User Record）内容，而非整个结构，整个结构实际就是一个页。**<font color="blue">**也就是说，这里的两个列时主键和页号。**</font>

- 页的用户记录中最小的主键值，用 key 表示。

- 页号，用 page_no 表示。
  ![Snipaste_2020-04-06_21-47-16](..\..\_img\Snipaste_2020-04-06_21-47-16.png)
  ![Snipaste_2020-04-06_23-00-04](..\..\_img\Snipaste_2020-04-06_23-00-04.png)

### 1.2.2 特点

- 结构与页相同，包含页的所有特点；

- 数据列固定，只包含索引列和页号；

- 记录头的信息 **record_type** 属性一定等于**1**；

  （因为所有数据，包括普通数据页中的数据，包括目录项页中的数据，都是连续存放在内存中，因此需要使用 record_type 来进行区分。）
  ![Snipaste_2020-04-06_22-04-20](..\..\_img\Snipaste_2020-04-06_22-04-20.png)

  

### 1.2.3 与普通数据页

- 目录项记录的 record_type = 1，而普通用户记录的 record_type = 0；

- 目录项记录只有主键值和页编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列信息；

- 目录项中的记录最小的数据的行的 min_rec_mask 值为1；

  （record_type 用来筛选目录项，而 min_rec_mask 则可以快速定位目录项的表头位置。）





### 1.2.4 多层级目录项

由于目录项记录的页在存储空间中也是不连续的，因此，为了快速定位目录项记录的页，则需要为目录项记录的页再生成一个跟高级的目录项（层层叠加）。
![Snipaste_2020-04-06_22-06-30](..\..\_img\Snipaste_2020-04-06_22-06-30.png)
![Snipaste_2020-04-06_22-06-57](..\..\_img\Snipaste_2020-04-06_22-06-57.png)



# 2 索引

## 2.1 聚簇索引

> <font color="blue">**聚簇索引的主键值应尽量是连续增长的值，不要随机值或UUID，否则会造成大量的页分裂与页移动。**</font>

- 使用记录主键值大小进行记录和页的排序。
  - 页内的记录是按照主键的大小顺序排成一个单向链表。
  - 各个存放用户记录的页是根据页中记录的主键大小顺序排成一个双向链表。
  - 各个存放目录项的页是根据页中记录的主键大小顺序排成一个双向链表。
- B+树的叶子节点存储的是完整的用户记录。

- 不需要显示创建，引擎自动创建。
- 聚簇索引就是数据的存储方式（所有的用户记录都存在叶子节点，<font color="blue">**索引即数据**</font>）。



## 2.2 二级索引

聚簇索引的B+树使用主键进行排序，而自定义的B+树可以采用其他的排序规则。

### 2.2.1 特性

- 使用记录 c 列的大小进行记录和页的排序
  - 1）页内的记录是按照 c 列值的大小顺序排成一个单向链表。
  - 2）各个存放用户记录的页是根据页中的记录的 c 列大小顺序排成一个双向链表。
  - 3）各个存放目录项的页也是根据页中的记录的 c 列大小顺序排成一个双向链表。
- B+树的叶子节点存储的并不是完整的用户记录，而是 <font color="blue">**c 列 + 主键**</font>。
- 目录项记录中不再是 <font color="blue">**主键 + 页号**</font>，而是 <font color="blue">**c 列 + 页号**</font>。

### 2.2.2 重点

#### 不需要回表（<font color="red">索引覆盖</font>）

如果一个索引包含（或覆盖）所有需要查询的字段值，则成为 『**覆盖索引**』，无需回表。

- 不用回表，减少二次查询，减少随机IO；
- 减少遍历数据页的数量。

如：直接通过 c 列的值查到某些记录的话，则使用二级索引的B+树即可：

```sql
select name from user where name = 1;
```

#### 需要回表

当二级索引的B+树不包含需要的数据时，需要根据查到的主键值，再去聚簇索引中查找完整的用户记录：

```sql
select name, age from user where c = 1;
```



## 2.3 组合索引

### 2.3.1 特性

只生成1颗B+树，却同时以多个列的大小作为排序规则，即让B+树按照 name 和 age 的大小进行排序：

- 先把各个记录和页按照 name 进行排序（<font color="blue">**最左优先**</font>）。
- 在记录的 name 列相同的情况下，采用 age 进行排序。
  ![Snipaste_2020-04-06_22-43-55](..\..\_img\Snipaste_2020-04-06_22-43-55.png)

### 2.3.2 推荐原则

- 联合索引总体选择性越高越好。
- 分组及排序时，让排序沿着某个索引顺序，防止二次排序。
- 在不考虑分组及排序时，尽量选择区分度高的列作为联合索引的前导列。B+树是按照前导列进行排序的，将选择性高的列放到前面能够最快地过滤出需要的记录。
- 联合索引长度不宜过长，可利用前缀索引降低索引条目长度。



## 2.4 前缀索引

### 2.4.1 示例

假设当前索引结构为联合索引：(c2, c3, c4)

- 对于 (c2, c3, c4) 这样的数据检索时，B+树按照从左到右的顺序来搜索。

- 如果没有 c2，按照 (c3, c4) 这样检索时，B+树会因为找不到 c2，而无法使用索引。

- 如果没有 c3，按照 (c2, c4) 这样检索时，B+树会先使用 c2 来指定搜索方向，但由于 c3 的缺失，所以只能等 c2 都找到，最后遍历匹配 c4。

### 2.4.2 重点特例

- 从左向右匹配，直到遇到范围查询（>、<、between、like）就停止匹配。

  ```sql
  where a = 1 and b = 2 and c > 3 and d = 4
  ```

  - 如果建立 (a, b, c, d) 顺序的索引，d 是用不到索引。
  - 如果建立 (a, b, d, c) 顺序的索引，则都可以用到。

- = 和 in 是可以乱序的，优化器会自动识别优化。

  ```sql
  where a = 1 and b = 2 and c = 3;
  where b = 2 and a = 1 and c = 3;
  ```

  - 以上两者都是可以使用 (a, b, c) 组合索引。









using index condition;

说明过滤了索引，ICP，索引下放特性；



# 3 索引排序

## 3.1 特点

> 由于检索使用到联合索引的数据，必定是有序的，则如果 order by 后面的条件，如果是按照联合索引的顺序，则不需要再次进行排序，否则还需要再次排序。

- order by 沿着某个索引的顺序，查询的结果本身就是有序的。

- 先取出数据，形成临时表做 filesort（文件可能在磁盘上，也可能在内存中）。



## 3.2 原则

- order by 语句使用了索引最左前缀。

- where 条件与 order by 条件的组合满足索引最左前缀。



## 3.3 示例

> 示例1

索引：(a, b, c)

- 使用索引

  ```sql
  select * from user order by a, b;
  select * from user where a = 1 order by b;
  ```

- 不使用索引

  ```sql
  # 无(c, b)索引
  select * from user where a = 1 order by c, b;
  # 因为最左前缀遇到非等号会重新计算
  select * from user where a > 1 order by b;
  ```

> 示例2

索引：(c1, c2, c3, c4)

- 正常使用c1索引和c4索引，不需要排序；

  ```sql
  # Using index condition; Using where
  select * from user where c1 = 1, c4 = 2 order by c2, c3;
  ```

- 虽然也会使用索引，但是最后会多出一步二次排序；

  ```sql
  # Using index condition; Using where; Using filesort
  select * from user where c1 = 1, c4 = 2 order by c3, c2;
  ```



# 4 索引分组

> MySQL 8.0 取消了对 GROUP BY 的默认排序！

由于 group by 会默认进行 order by，因此效果也是一样的，如果不需要 order by，则需要取消排序。



